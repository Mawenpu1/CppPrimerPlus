# 函数探幽

## 内联函数

常规函数使用中断将程序执行流程跳转到函数入口地址，内联函数将代码直接复制到调用处，使用内联代码替换函数调用

声明内联函数，通常将函数原型和整个函数定义放在本该放函数原型的地方

```c++
inline double square(double x){return x*x;}
int main()
{
    using namespace std;
    cout<<square(5)<<endl;
    return 0;
}
```

## 引用

声明

```c++
int a;
int &b = a;
```

引用变量是另一个变量的别名，两个变量值相同地址也相同

引用变量必须在声明时初始化，类似于const指针

```c++
int a = 10;
int* const pt = &a;
```

引用变量由于是变量别名，为引用变量重新赋值就是给原来的变量重新赋值

不能把数值或表达式直接传递给非const引用声明的函数参数

```c++
#include<iostream>
void Show(int& n);
int main()
{
	using namespace std;
	int n = 3;
	Show(n);
	Show(n + 3);//错误，非常量引用的初始值必须为左值
	Show(3);//错误，非常量引用的初始值必须为左值
	return 0;
}

void Show(int& n)
{
	std::cout << n << std::endl;
}
```

**当参数为const引用时，编译器会生成临时变量保存表达式的值**

```c++
#include<iostream>
void Show(const int& n);
int main()
{
	using namespace std;
	int n = 3;
	Show(n);
	Show(n + 3);//生成临时变量
	Show(3);//生成临时变量
	return 0;
}

void Show(const int &n)
{
	std::cout << n << std::endl;
}
```

+ 使用const可以防止误修改数据
+ 使用const可以使函数接收const和非const参数
+ 使用const可以生成临时变量接收表达式和字面量的值

## 结构引用

在函数返回时使用引用，返回的变量可以直接复制给用于接收返回值的变量（如果变量是非引用类型），按值传递则会先将返回值复制给一个临时变量，再将临时变量复制给用于接收函数返回值的变量

应该避免函数中声明的临时变量作为引用返回，这个变量在函数结束后会被释放，应该将要返回的变量作为参数传递

或者可以在代码中用new或指针声明一个新的内存块返回

```c++
struct point
{
    int x;
    int y;
};
const point& accumulate(point& A,const point& B)
{
    A.X +=B.X;
    A.y+=B.y;
    return A;
}
```

返回的引用可以被重新赋值，如果accumulate返回值没有被声明为const，则可以给accumulate的返回值赋值

```c++
accumulate(A,B) = C;
```

因此，需要将引用的返回值声明为const，这样只能用const引用接收函数参数，无法用非const引用接收

> 返回const引用的函数只能用const引用去接收，但可以使用const和非const非引用变量接收，使用const引用变量接收是为了防止引用对返回值进行修改，而常规变量接收的是返回值的拷贝，可以进行修改

## 将引用用于类对象

```c++
#include<iostream>
#include<string>
using std::string;
const string& version1(string& s1, const string& s2);
const string& version2(string& s1, const string& s2);
int main()
{
	using namespace std;
	string s1 = "aaaaaa";
	string s2 = "***";
	const string &s = version1(s1, s2);
	const string& ss = version2(s1, s2);
	cout << s << endl;
	cout << ss << endl;
	return 0;
}

const string& version1(string& s1, const string& s2)
{
	s1 = s2 + s1 + s2;
	return s1;
}

const string& version2(string& s1, const string& s2)
{
	string temp = s2 + s1 + s2;
	return temp;
}
```

在上面的代码中，version1返回的是第一个参数的引用，由于s1是外部参数，将一直存在，所以version1可以正确运行。

在version2中，temp是临时变量，函数运行结束后会被销毁，而此时ss变成了一个已经被销毁变量的引用，指向了一个未知的内存块，可能会导致程序崩溃

在这里，返回值应该被声明为string，这样返回的就是temp的字面值

## 何时使用引用参数

+ 程序员需要修改调用函数中的数据对象，和指针类似
+ 通过传递引用，可以提高程序的运行速度

对于不对传递值进行修改的函数：

+ 如果数据对象很小，直接按值传递
+ 如果是数组，只能用指针+数组长度传递
+ 如果数据对象是较大的结构，使用const指针或const引用传递
+ 如果数据对象是类对象，使用const引用传递，const引用就是为了类对象设计的

## 默认参数

默认参数需要在函数原型中声明，所有默认参数右边的值都应该有默认值

```c++
const chat* cut(const char* str,int n = 1);//默认参数
int main()
{
    
}

const chat* cut(const char* str,int n)
{
    //pass
}
```

## 左值引用和右值引用

左值：可以放在赋值运算符左边的值

右值：可以放在赋值运算符右边的值

可以取地址的都是左值，不能取地址的都是右值

### 左值引用

```c++
int &c = a;
```

在定义引用时，赋值运算符的右边一定是左值，传统C++引用

### 常引用

```c++
int a = 10;
int b = 20;
const int &c = 10;
const int &d = a+b;
```

常引用由于左右两边都是常量，是正确的，这时**引用变量关联的是内存中用于存储计算结果的临时变量**，但是使用常引用后的变量是只读的

### 右值引用

```c++
int &&x = 10;
```

使用**&&**定义的右值引用可以和右值进行关联

## 函数重载

函数重载会将不匹配原型的实参强制转换，如果由多个原型可供函数进行强制转换，则编译器会拒绝这次函数调用

非引用和引用变量不算是不同的特征标，编译器在检查特征标时，将把类型引用和类型本身视为一个特征标

```c++
double cube(double x);
double cube(double& x);
//这两个函数被视为一个，并不是函数重载
```

函数重载会区分非const和const常量

```c++
void dribble(char* bits);
void dribble(const char* cbits);//函数重载
const char p1[20];
char p2[20];
dribble(p1);//调用第二个函数
dribble(p2);//调用第一个函数
```

***函数重载时，编译器只会承认函数的特征标，即参数量与参数类型，并不会看函数的返回值，当两个函数特征标相同返回值不同时，不是函数重载，返回值不同，特征标也应该不同***

有如下重载：

```c++
void stove(double& r1);
void stove(const double& r2);
void stove(double&& r3);
double x = 55.5;
const double y = 32.0;
stove(x);
stove(y);
stove(x+y);
```

第一个调用使用了第一个重载函数，第二个const调用使用了第二个带const的重载函数，第三个调用中，x+y为右值，因此调用了右值引用的第三个重载函数，**如果没有右值引用重载函数，则会调用const引用的版本**

## 函数模板

在***函数定义和函数声明前***加上该语句

```c++
template <typename T>
```



